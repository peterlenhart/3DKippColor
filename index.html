<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D WÃ¼rfel - VollstÃ¤ndig</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #000000;
      overflow: hidden;
      touch-action: none;
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
    }

    #container { 
      position: fixed;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 360px;
      height: 720px;
    }

    #container canvas {
      position: absolute;
      top: 0;
      left: 0;
    }

    /* UI OVERLAY */
    #uiOverlay {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 360px;
      height: 100vh;
      pointer-events: none;
      z-index: 100;
    }

    #hintText {
      position: absolute;
      top: 425px;
      left: 180px;
      transform: translateX(-50%);
      text-align: center;
      font-size: 24px;
      font-weight: bold;
      background: linear-gradient(180deg, #ffffff 0%, #f0f0f0 50%, #e0e0e0 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                   0 0 10px rgba(255,255,255,0.5);
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.5));
      pointer-events: none;
      white-space: nowrap;
    }

    #countdown {
      position: absolute;
      top: 475px;
      left: 180px;
      transform: translateX(-50%);
      font-size: 50px;
      font-weight: bold;
      background: linear-gradient(180deg, #ffffff 0%, #f0f0f0 50%, #e0e0e0 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                   0 0 10px rgba(255,255,255,0.5);
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.5));
      pointer-events: none;
      display: none;
    }

    #actionButton {
      position: absolute;
      top: 560px;
      left: 180px;
      transform: translateX(-50%);
      padding: 8px 28px;
      background: linear-gradient(180deg, #606060 0%, #404040 100%);
      border: 2px solid #808080;
      border-radius: 8px;
      font-size: 22px;
      font-weight: bold;
      color: #c0b8a8;
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 4px 8px rgba(0,0,0,0.4),
                  inset 0 1px 0 rgba(255,255,255,0.8);
      transition: all 0.15s ease;
      white-space: nowrap;
    }

    #actionButton:hover {
      background: linear-gradient(180deg, #6a6a6a 0%, #4a4a4a 100%);
      transform: translateX(-50%) translateY(-2px);
    }

    #actionButton:active {
      transform: translateX(-50%) translateY(0);
      background: linear-gradient(180deg, #505050 0%, #303030 100%);
    }

    #actionButton.pulse {
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.05); }
    }

    @keyframes kippPulse {
      0%, 100% { box-shadow: 0 0 4px rgba(212,180,140,0.2); }
      50% { box-shadow: 0 0 10px rgba(212,180,140,0.7), 0 0 22px rgba(212,180,140,0.4); }
    }
    .kippBtn.pulsing {
      animation: kippPulse 1.2s ease-in-out infinite;
    }

    /* PLATZHALTER-RECHTECKE */
    #placeholderRow {
      position: absolute;
      top: 443px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      pointer-events: none;
    }

    .placeholder {
      width: 45px;
      height: 90px;
      background: linear-gradient(to bottom, #888888 50%, #a08060 50%);
      border-radius: 4px;
    }

    /* BUTTONS 1-6 */
    #kippButtons {
      position: absolute;
      top: 575px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 6px;
      pointer-events: auto;
      z-index: 200;
    }

    .kippBtn {
      width: 52px;
      height: 52px;
      background: linear-gradient(180deg, #606060 0%, #404040 100%);
      border: 2px solid #808080;
      border-radius: 8px;
      font-size: 20px;
      font-weight: bold;
      color: #c0b8a8;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.4);
      transition: all 0.15s ease;
      pointer-events: auto;
    }

    #cwBtn, #ccwBtn {
      background: linear-gradient(180deg, #404040 0%, #303030 100%);
    }
      background: linear-gradient(180deg, #ffffff 0%, #f8f8f8 50%, #f0f0f0 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.5),
                  inset 0 1px 0 rgba(255,255,255,0.9);
    }

    .kippBtn:active:not(:disabled) {
      transform: translateY(0);
      background: linear-gradient(180deg, #f0f0f0 0%, #e0e0e0 50%, #d0d0d0 100%);
      box-shadow: 0 2px 4px rgba(0,0,0,0.4),
                  inset 0 1px 2px rgba(0,0,0,0.2);
    }

    .kippBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .kippBtn.running {
      background: linear-gradient(180deg, #ffdd00 0%, #ffcc00 50%, #ffbb00 100%);
      border-color: #cc9900;
    }

    .kippBtn.clicked {
      background: linear-gradient(180deg, #4a3e28 0%, #3a2e1c 100%) !important;
      border-color: #d4b48c !important;
      color: #f0e0c0 !important;
      box-shadow: 0 0 8px rgba(212,180,140,0.6), 0 0 20px rgba(212,180,140,0.35), inset 0 0 6px rgba(212,180,140,0.15);
    }

    #backButton {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      background: linear-gradient(180deg, #ffffff 0%, #f0f0f0 50%, #e0e0e0 100%);
      border: 1px solid #c0c0c0;
      border-radius: 50%;
      font-size: 20px;
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 2px 4px rgba(0,0,0,0.4),
                  inset 0 1px 0 rgba(255,255,255,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
    }

    #backButton:active {
      transform: scale(0.95);
      background: linear-gradient(180deg, #f0f0f0 0%, #e0e0e0 50%, #d0d0d0 100%);
      box-shadow: 0 1px 2px rgba(0,0,0,0.4),
                  inset 0 1px 2px rgba(0,0,0,0.2);
    }

    #handIcon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      width: 60px;
      height: 60px;
      font-size: 50px;
      pointer-events: none;
      top: 270px;
      display: none;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  
  <div id="uiOverlay">
    <div id="handIcon">ðŸ‘†</div>
    <div id="hintText">KIPPE UND MERKE!</div>
    <div id="countdown">60</div>
    <button id="actionButton">weiter</button>
    <button id="backButton">â†»</button>
    
    <!-- Platzhalter-Rechtecke (Phase 3) -->
    <div id="placeholderRow" class="hidden">
      <div class="placeholder" id="targetRect"></div>
      <div class="placeholder"></div>
      <div class="placeholder"></div>
      <div class="placeholder"></div>
      <div class="placeholder"></div>
      <div class="placeholder"></div>
    </div>
    <div id="richtungButtons" class="hidden" style="position:absolute;top:520px;left:50%;transform:translateX(-50%);display:flex;gap:21px;width:180px;z-index:200;">
      <button id="cwBtn" class="kippBtn" style="flex:1;height:45px;font-size:40px;line-height:1;position:relative;"><span style="position:absolute;top:calc(50% - 3px);left:50%;transform:translate(-50%,-50%);font-size:40px;">â†»</span></button>
      <button id="ccwBtn" class="kippBtn" style="flex:1;height:45px;font-size:40px;line-height:1;position:relative;"><span style="position:absolute;top:calc(50% - 3px);left:50%;transform:translate(-50%,-50%);font-size:40px;">â†º</span></button>
    </div>

    <!-- Buttons 1-6 - VernÃ¼nftig positioniert -->
    <div id="kippButtons" class="hidden">
      <button class="kippBtn" data-anzahl="1">1</button>
      <button class="kippBtn" data-anzahl="2">2</button>
      <button class="kippBtn" data-anzahl="3">3</button>
      <button class="kippBtn" data-anzahl="4">4</button>
      <button class="kippBtn" data-anzahl="5">5</button>
      <button class="kippBtn" data-anzahl="6">6</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // =========================
    // Scene Setup
    // =========================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1c1c1e);

    const containerWidth = 360;
    const containerHeight = 720;
    
    const camera = new THREE.PerspectiveCamera(
      50,
      containerWidth / containerHeight,
      0.01,
      100
    );
    
    const baseY = 2.143;
    const verticalAngle = -1.0;
    const horizontal = 0;
    const radius = 1.25;
    const southShift = -0.143;
    
    camera.position.set(
      0 + Math.sin(horizontal) * 0.5,
      baseY + radius * Math.sin(-verticalAngle),
      radius * Math.cos(verticalAngle) + Math.cos(horizontal) * 0.3 + southShift
    );
    
    camera.lookAt(0, 0.46875, 0.7 + southShift);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(360, 720);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    document.getElementById('container').appendChild(renderer.domElement);

    // =========================
    // BELEUCHTUNG
    // =========================
    // ZusÃ¤tzliche Pause-Lichter (von allen Seiten, subtil)
    const pauseLights = [
      new THREE.DirectionalLight(0xffffff, 0.25), // links
      new THREE.DirectionalLight(0xffffff, 0.25), // rechts
      new THREE.DirectionalLight(0xffffff, 0.2),  // hinten
      new THREE.DirectionalLight(0xffffff, 0.15)  // unten
    ];
    pauseLights[0].position.set(-3, 2, 1);
    pauseLights[1].position.set(3, 2, 1);
    pauseLights[2].position.set(0, 2, -3);
    pauseLights[3].position.set(0, -1, 2);
    pauseLights.forEach(l => { l.visible = false; scene.add(l); });

    const mainLight = new THREE.DirectionalLight(0xffffff, 0.6);
    mainLight.position.set(0, 8.708, -0.46875);
    mainLight.castShadow = false;
    scene.add(mainLight);

    const fillLight = new THREE.DirectionalLight(0xffffff, 0.2);
    fillLight.position.set(1, 3, 1);
    scene.add(fillLight);

    const fillLightSouth = new THREE.DirectionalLight(0xffffff, 0.25);
    fillLightSouth.position.set(0, 2, 4);
    scene.add(fillLightSouth);

    // =========================
    // TISCH (Ï€1 Ebene)
    // =========================
    const woodBase64 = "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";
    const tableGeometry = new THREE.PlaneGeometry(5, 5);
    const woodImg = new Image();
    woodImg.src = 'data:image/jpeg;base64,' + woodBase64;
    const woodTexture = new THREE.Texture(woodImg);
    woodImg.onload = () => { woodTexture.needsUpdate = true; };
    const tableMaterial = new THREE.MeshStandardMaterial({
      map: woodTexture,
      roughness: 0.8,
      metalness: 0.1
    });
    const table = new THREE.Mesh(tableGeometry, tableMaterial);
    table.rotation.x = -Math.PI / 2;
    table.position.y = 0;
    table.receiveShadow = true;
    scene.add(table);


    // =========================
    // BOX-BODEN SPRITE auf Ï€1
    // =========================
    const textureLoader = new THREE.TextureLoader();
    const boxBodenTexture = textureLoader.load('boxboden.webp');
    
    // Box-Boden: 6Ã—6 Zellen = 0.9375 Ã— 0.9375 Einheiten
    const boxBodenGeometry = new THREE.PlaneGeometry(0.9375, 0.9375);
    const boxBodenMaterial = new THREE.MeshStandardMaterial({
      map: boxBodenTexture,
      roughness: 0.7,
      metalness: 0.2
    });
    const boxBoden = new THREE.Mesh(boxBodenGeometry, boxBodenMaterial);
    boxBoden.rotation.x = -Math.PI / 2;  // horizontal auf Ï€1
    boxBoden.position.set(0, 0.001, 0.1105);  // zentriert am orangen Achsmittelpunkt
    boxBoden.receiveShadow = true;
    scene.add(boxBoden);

    // =========================
    // 3D GRID auf Ï€1
    // =========================
    const gridSize = 16 * 0.15625;
    const gridDivisions = 16;
    
    const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0xff8800, 0xff8800);
    gridHelper.position.y = 0.001;
    gridHelper.position.z = 0.421875;
    gridHelper.material.opacity = 0.3;
    gridHelper.material.transparent = true;
    scene.add(gridHelper);
    
    const gridHelper2 = new THREE.GridHelper(gridSize, gridDivisions, 0xffffff, 0x888888);
    gridHelper2.position.y = 0.46875;
    gridHelper2.position.z = 0.421875;
    gridHelper2.material.opacity = 0.3;
    gridHelper2.material.transparent = true;
    scene.add(gridHelper2);

    // KÃ¤rtchen auf dem Spieltisch (Ï€1, orange Raster)
    const cardWidth = 0.15625;   // 1 Zelle
    const cardHeight = 0.3125;   // 2 Zellen
    const cardGap = (1.25 - 6 * cardWidth) / 5; // 6 Karten auf 8 Zellen verteilt
    const cardY = 0.001 + 0.002; // auf Ï€1
    const cardZ = 0.109375 + 4 * 0.15625 + 0.15625; // 4 Zeilen sÃ¼dlich von X-Achse, Kartenmitte

    const totalCardsWidth = 8 * cardWidth; // 8 Zellen
    const cardStartX = -totalCardsWidth / 2 + cardWidth / 2;

    const gameCards = [];
    for (let i = 0; i < 6; i++) {
      const canvas = document.createElement('canvas');
      canvas.width = 85;
      canvas.height = 170;
      const ctx = canvas.getContext('2d');
      // Platzhalter: oben grau, unten beige
      ctx.fillStyle = '#888888';
      ctx.fillRect(0, 0, 85, 85);
      ctx.fillStyle = '#a08060';
      ctx.fillRect(0, 85, 85, 85);

      const texture = new THREE.CanvasTexture(canvas);
      const geo = new THREE.PlaneGeometry(cardWidth, cardHeight);
      const mat = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.8, metalness: 0.0, side: THREE.DoubleSide });
      const plane = new THREE.Mesh(geo, mat);
      plane.rotation.x = -Math.PI / 2;
      plane.position.set(cardStartX + i * (cardWidth + cardGap), cardY, cardZ);
      plane.receiveShadow = true;
      scene.add(plane);
      plane.visible = false;

      gameCards.push({ mesh: plane, canvas: canvas, ctx: ctx, texture: texture });
    }
    // =========================
    // GRADIENT SCHATTEN ÃœBER KÃ„RTCHEN
    // =========================
    // KÃ¤rtchen: X Â±0.625, Z von 0.734375 bis 1.046875
    const shadowGradCanvas = document.createElement('canvas');
    shadowGradCanvas.width = 512;
    shadowGradCanvas.height = 512;
    const sgCtx = shadowGradCanvas.getContext('2d');
    const grad = sgCtx.createLinearGradient(0, 0, 0, 512); // oben nach unten
    grad.addColorStop(0, 'rgba(0, 0, 0, 0.5)');   // Nord: schwarz
    grad.addColorStop(0.5, 'rgba(0, 0, 0, 0.0)'); // Mitte: transparent
    grad.addColorStop(1, 'rgba(0, 0, 0, 0.0)');   // SÃ¼d: transparent
    sgCtx.fillStyle = grad;
    sgCtx.fillRect(0, 0, 512, 512);

    const shadowGradTexture = new THREE.CanvasTexture(shadowGradCanvas);
    const shadowGradW = 1.25;    // 8 Zellen
    const shadowGradH = 0.3125;  // 2 Zellen = KÃ¤rtchenhÃ¶he
    const shadowGradGeo = new THREE.PlaneGeometry(shadowGradW, shadowGradH);
    const shadowGradMat = new THREE.MeshBasicMaterial({ map: shadowGradTexture, transparent: true });
    const shadowGradPlane = new THREE.Mesh(shadowGradGeo, shadowGradMat);
    shadowGradPlane.rotation.x = -Math.PI / 2;
    shadowGradPlane.position.set(0, 0.004, 0.890625); // cardZ
    shadowGradPlane.visible = false;
    scene.add(shadowGradPlane);


    // =========================
    // ACHSEN (X und Z)
    // =========================
    const axesMaterialPi1 = new THREE.LineBasicMaterial({ 
      color: 0xff8800, 
      linewidth: 2,
      opacity: 0.9,
      transparent: true
    });
    
    const axesMaterial = new THREE.LineBasicMaterial({ 
      color: 0xffffff, 
      linewidth: 2,
      opacity: 0.9,
      transparent: true
    });

    const xAxisGeometry1 = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-2.5, 0.002, 0.109375),
      new THREE.Vector3(2.5, 0.002, 0.109375)
    ]);
    const xAxis1 = new THREE.Line(xAxisGeometry1, axesMaterialPi1);
    scene.add(xAxis1);

    const zAxisGeometry1 = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0.002, -2.5),
      new THREE.Vector3(0, 0.002, 2.5)
    ]);
    const zAxis1 = new THREE.Line(zAxisGeometry1, axesMaterialPi1);
    scene.add(zAxis1);

    const xAxisGeometry2 = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-2.5, 0.46875, 0.109375),
      new THREE.Vector3(2.5, 0.46875, 0.109375)
    ]);
    const xAxis2 = new THREE.Line(xAxisGeometry2, axesMaterial);
    scene.add(xAxis2);

    const zAxisGeometry2 = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0.46875, -2.5),
      new THREE.Vector3(0, 0.46875, 2.5)
    ]);
    const zAxis2 = new THREE.Line(zAxisGeometry2, axesMaterial);
    scene.add(zAxis2);

    // =========================
    // WÃ„NDE
    // =========================
    const wallGeometry = new THREE.BoxGeometry(0.9375, 0.46875, 0.0335);
    const wallMaterial = new THREE.MeshStandardMaterial({
      color: 0xc0c0c0,
      metalness: 0.7,
      roughness: 0.3
    });
    
    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
    wall.position.set(0, 0.234375, 0.597125);
    wall.castShadow = true;
    wall.receiveShadow = true;
    scene.add(wall);

    const wall2 = new THREE.Mesh(wallGeometry, wallMaterial);
    wall2.position.set(0, 0.234375, -0.376125);
    wall2.castShadow = true;
    wall2.receiveShadow = true;
    scene.add(wall2);

    // =========================
    // SEITENWÃ„NDE
    // =========================
    const sideWallGeometry = new THREE.BoxGeometry(0.0335, 0.46875, 1.00675);
    
    const wallLeft = new THREE.Mesh(sideWallGeometry, wallMaterial);
    wallLeft.position.set(-0.48550, 0.234375, 0.1105);
    wallLeft.castShadow = true;
    wallLeft.receiveShadow = true;
    scene.add(wallLeft);
    
    const wallRight = new THREE.Mesh(sideWallGeometry, wallMaterial);
    wallRight.position.set(0.48550, 0.234375, 0.1105);
    wallRight.castShadow = true;
    wallRight.receiveShadow = true;
    scene.add(wallRight);

    // =========================
    // SCHWARZER RAHMEN (3 Zellen Ã¼ber Ï€1)
    // =========================
    // WICHTIG: WÃ¤nde sind nach SÃ¼den verschoben um 0.1105!
    // InnenmaÃŸ: 6Ã—6 Zellen (0.9375 Ã— 0.9375)
    // Rahmenbreite: 1 Zelle rundum (0.15625)
    // Z-Mittelpunkt: 0.1105 (wie SeitenwÃ¤nde)
    
    const frameHeight = 0.46875; // 3 Zellen Ã¼ber Ï€1
    const frameThickness = 0.02; // Minimale Dicke in Y
    const frameWidth = 0.15625; // 1 Zelle breit
    
    // TatsÃ¤chliche Wand-Innenkanten:
    const wallInnerNorth = -0.359375;
    const wallInnerSouth = 0.579875;
    const wallInnerWest = -0.46875;
    const wallInnerEast = 0.46875;
    const wallCenterZ = 0.1105; // Z-Verschiebung des Spielbereichs
    
    const frameMaterial = new THREE.MeshStandardMaterial({
      color: 0x000000,
      roughness: 0.9,
      metalness: 0.1
    });
    
    // Nord-Balken (an Nord-Innenkante)
    const northFrame = new THREE.Mesh(
      new THREE.BoxGeometry(1.25, frameThickness, frameWidth), // 8 Zellen breit
      frameMaterial
    );
    northFrame.position.set(0, frameHeight, wallInnerNorth - frameWidth/2);
    northFrame.castShadow = true;
    northFrame.receiveShadow = true;
    scene.add(northFrame);
    
    // SÃ¼d-Balken (an SÃ¼d-Innenkante)
    const southFrame = new THREE.Mesh(
      new THREE.BoxGeometry(1.25, frameThickness, frameWidth), // 8 Zellen breit
      frameMaterial
    );
    southFrame.position.set(0, frameHeight, wallInnerSouth + frameWidth/2);
    southFrame.castShadow = true;
    southFrame.receiveShadow = true;
    scene.add(southFrame);
    
    // West-Balken (an West-Innenkante, zentriert auf Z=0.1105)
    const westFrame = new THREE.Mesh(
      new THREE.BoxGeometry(frameWidth, frameThickness, 0.9375), // 6 Zellen lang
      frameMaterial
    );
    westFrame.position.set(wallInnerWest - frameWidth/2, frameHeight, wallCenterZ);
    westFrame.castShadow = true;
    westFrame.receiveShadow = true;
    scene.add(westFrame);
    
    // Ost-Balken (an Ost-Innenkante, zentriert auf Z=0.1105)
    const eastFrame = new THREE.Mesh(
      new THREE.BoxGeometry(frameWidth, frameThickness, 0.9375), // 6 Zellen lang
      frameMaterial
    );
    eastFrame.position.set(wallInnerEast + frameWidth/2, frameHeight, wallCenterZ);
    eastFrame.castShadow = true;
    eastFrame.receiveShadow = true;
    scene.add(eastFrame);

    // =========================
    // RAHMEN-KANTEN 6px silbergrau inline
    // =========================
    const lineW = 4 * (2.5 / 720); // 4px in Three.js
    const lineThick = 0.002;
    const lineY = frameHeight + frameThickness / 2 + 0.0005;
    const lineMat = new THREE.MeshBasicMaterial({ color: 0x606060 });

    // Ã„uÃŸere Kanten des Rahmens
    const outerN = wallInnerNorth - frameWidth; // -0.515625
    const outerS = wallInnerSouth + frameWidth; // 0.736125
    const outerW = wallInnerWest - frameWidth;  // -0.625
    const outerE = wallInnerEast + frameWidth;  // 0.625
    const outerMidZ = (outerN + outerS) / 2;

    // Ã„uÃŸere Perimeter: N/S/W/E inline
    const outerLines = [
      { geo: new THREE.BoxGeometry(1.25, lineThick, lineW),                pos: [0, lineY, outerN + lineW/2] },  // N auÃŸen
      { geo: new THREE.BoxGeometry(1.25, lineThick, lineW),                pos: [0, lineY, outerS - lineW/2] },  // S auÃŸen
      { geo: new THREE.BoxGeometry(lineW, lineThick, outerS - outerN),     pos: [outerW + lineW/2, lineY, outerMidZ] }, // W auÃŸen
      { geo: new THREE.BoxGeometry(lineW, lineThick, outerS - outerN),     pos: [outerE - lineW/2, lineY, outerMidZ] }  // E auÃŸen
    ];
    outerLines.forEach(l => {
      const m = new THREE.Mesh(l.geo, lineMat);
      m.position.set(...l.pos);
      scene.add(m);
    });

    // Innere Kanten (Innenausschnitt)
    const innerMidZ = (wallInnerNorth + wallInnerSouth) / 2;
    const innerSpanZ = wallInnerSouth - wallInnerNorth;

    const innerLines = [
      { geo: new THREE.BoxGeometry(0.9375 + 2 * lineW, lineThick, lineW),  pos: [0, lineY, wallInnerNorth - lineW/2] }, // N innen
      { geo: new THREE.BoxGeometry(0.9375 + 2 * lineW, lineThick, lineW),  pos: [0, lineY, wallInnerSouth + lineW/2] }, // S innen
      { geo: new THREE.BoxGeometry(lineW, lineThick, innerSpanZ),         pos: [wallInnerWest - lineW/2, lineY, innerMidZ] }, // W innen
      { geo: new THREE.BoxGeometry(lineW, lineThick, innerSpanZ),         pos: [wallInnerEast + lineW/2, lineY, innerMidZ] }  // E innen
    ];
    innerLines.forEach(l => {
      const m = new THREE.Mesh(l.geo, lineMat);
      m.position.set(...l.pos);
      scene.add(m);
    });

    // =========================
    // FARBQUADRATE AUF RAHMEN
    // =========================
    const colorY = frameHeight + frameThickness / 2 + 0.001; // Direkt auf Rahmen-OberflÃ¤che
    const cellSize = 0.15625; // 1 Zelle
    const colorThick = 0.002;

    // Spalten X-Zentren (A=1..H=8), Frame links bei -0.625
    function colX(letter) {
      const idx = letter.charCodeAt(0) - 'A'.charCodeAt(0); // A=0..H=7
      return -0.625 + cellSize / 2 + idx * cellSize;
    }

    // Zeilen Z-Zentren: Zeile 4 beginnt bei wallInnerNorth
    function rowZ(row) {
      return wallInnerNorth + (row - 4) * cellSize + cellSize / 2;
    }

    const COLORS = {
      violett: 0xa41b85,
      blau:    0x006bb3,
      gruen:   0x00a652,
      orange:  0xe67814
    };

    const colorSqSize = cellSize * 42 / 45; // 42px in Three.js-Einheiten

    const colorSquareMeshes = {};

    function addColorSquare(x, z, color, key) {
      const geo = new THREE.BoxGeometry(colorSqSize, colorThick, colorSqSize);
      const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.8, metalness: 0.1 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x, colorY, z);
      scene.add(mesh);
      if (key) colorSquareMeshes[key] = mesh;
    }

    // Nord-Rahmen (Zeile 3)
    const nordZ = wallInnerNorth - frameWidth / 2;
    addColorSquare(colX('C'), nordZ, COLORS.gruen, 'Nord_C');
    addColorSquare(colX('D'), nordZ, COLORS.orange, 'Nord_D');
    addColorSquare(colX('E'), nordZ, COLORS.orange, 'Nord_E');
    addColorSquare(colX('F'), nordZ, COLORS.blau, 'Nord_F');

    // SÃ¼d-Rahmen (Zeile 10)
    const sÃ¼dZ = wallInnerSouth + frameWidth / 2;
    addColorSquare(colX('C'), sÃ¼dZ, COLORS.gruen, 'SÃ¼d_C');
    addColorSquare(colX('D'), sÃ¼dZ, COLORS.violett, 'SÃ¼d_D');
    addColorSquare(colX('E'), sÃ¼dZ, COLORS.violett, 'SÃ¼d_E');
    addColorSquare(colX('F'), sÃ¼dZ, COLORS.blau, 'SÃ¼d_F');

    // West-Rahmen (Spalte A): 5â†”8 getauscht
    const westX = wallInnerWest - frameWidth / 2;
    addColorSquare(westX, rowZ(5), COLORS.violett, 'West_5');
    addColorSquare(westX, rowZ(6), COLORS.blau, 'West_6');
    addColorSquare(westX, rowZ(7), COLORS.blau, 'West_7');
    addColorSquare(westX, rowZ(8), COLORS.orange, 'West_8');

    // Ost-Rahmen (Spalte H)
    const ostX = wallInnerEast + frameWidth / 2;
    addColorSquare(ostX, rowZ(5), COLORS.violett, 'Ost_5');
    addColorSquare(ostX, rowZ(6), COLORS.gruen, 'Ost_6');
    addColorSquare(ostX, rowZ(7), COLORS.gruen, 'Ost_7');
    addColorSquare(ostX, rowZ(8), COLORS.orange, 'Ost_8');


    // =========================
    // WÃœRFEL mit 3x3 Grid-Textur
    // =========================
    // WÃ¼rfel-Textur WebP
    const cubeTexImg = new Image();
    cubeTexImg.src = 'data:image/webp;base64,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';
    const cubeSize = 0.46875;

    // Randomdeck 1-12 mischen
    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }
    const deck = shuffle([1,2,3,4,5,6,7,8,9,10,11,12]);

    // Slot-Zuordnung: welche Zelle auf welcher Face â†’ deck-Index
    // f0: 7=S1, 4=S2, 2=S3, 3=S4
    // f1: 10=S1, 11=S2, 15=S3, 18=S4
    // f2: 27=S1, 26=S2, 22=S3, 19=S4
    // deck[0-3] â†’ f0 Slots, deck[4-7] â†’ f1 Slots, deck[8-11] â†’ f2 Slots

    // Canvas-Textur: 3x3 Gitter, slotMap = { "row,col": { val, rot } }
    function createFaceTexture(slotMap, imgRotation) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      const cell = 256 / 3;

      // WÃ¼rfel-Textur als Hintergrund (optional rotiert, SÃ¤ttigung reduziert)
      ctx.save();
      ctx.translate(128, 128);
      if (imgRotation) ctx.rotate(imgRotation);
      ctx.drawImage(cubeTexImg, -128, -128, 256, 256);
      ctx.restore();

      // Slot-Zellen beschriften
      ctx.fillStyle = '#2a1810';
      ctx.font = 'bold 56px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (const key in slotMap) {
        const [r, c] = key.split(',').map(Number);
        const { val, rot } = slotMap[key];
        const cx = c * cell + cell / 2;
        const cy = r * cell + cell / 2;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(rot);
        // Zweistellige Zahlen leicht nach links fÃ¼r optische Zentrierung
        const xOff = val >= 10 ? -4 : 0;
        ctx.fillText(val.toString(), xOff, 0);
        // Punkt bei 6 und 9: Satzpunkt nach der Zahl, gleiche Baseline
        if (val === 6 || val === 9) {
          ctx.beginPath();
          ctx.arc(xOff + 22, 18, 4, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      // Gitterlinien
      ctx.strokeStyle = '#c4a882';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(85, 0);   ctx.lineTo(85, 256);
      ctx.moveTo(171, 0);  ctx.lineTo(171, 256);
      ctx.moveTo(0, 85);   ctx.lineTo(256, 85);
      ctx.moveTo(0, 171);  ctx.lineTo(256, 171);
      ctx.stroke();

      // Rand
      ctx.strokeStyle = '#6b5040';
      ctx.lineWidth = 6;
      ctx.strokeRect(3, 3, 250, 250);

      return canvas;
    }

    function mat(slotMap, imgRotation) {
      return new THREE.MeshStandardMaterial({
        map: new THREE.CanvasTexture(createFaceTexture(slotMap || {}, imgRotation)),
        metalness: 0.3, roughness: 0.7
      });
    }

    // Material-Array: [+X, -X, +Y, -Y, +Z, -Z]
    // Rotationen per-Slot:
    // f2 (+Y): S1,S2 von SÃ¼den lesbar (0), S3,S4 von Westen lesbar (-Ï€/2)
    // f0 (+Z): S1,S2 von Westen lesbar (-Ï€/2), S3,S4 stehen Kopf (Ï€)
    // f1 (-X): S1,S2 stehen Kopf (Ï€), S3,S4 von SÃ¼den lesbar (Ï€/2)
    let cubeMaterial = [];
    const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
    const offset = cubeSize / 2;

    // =========================
    // KANTEN-KIPP-WÃœRFEL
    // =========================
    const kipGroup = new THREE.Group();
    kipGroup.visible = true;
    scene.add(kipGroup);
    
    const cube = new THREE.Mesh(cubeGeometry, []);
    cube.position.set(-offset, offset, 0.109375 + offset);
    cube.castShadow = true;
    cube.receiveShadow = true;
    kipGroup.add(cube);

    // Materialien erst wenn Textur-Image geladen
    cubeTexImg.onload = function() {
      cubeMaterial = [
        mat(null),            // [0] +X  â€“ leer
        mat({                 // [1] -X  = f1
          '0,0': { val: deck[4],  rot: Math.PI },
          '0,1': { val: deck[5],  rot: Math.PI },
          '1,2': { val: deck[6],  rot: -Math.PI / 2 },
          '2,2': { val: deck[7],  rot: -Math.PI / 2 }
        }, Math.PI / 2),
        mat({                 // [2] +Y  = f2
          '2,2': { val: deck[8],  rot: 0 },
          '2,1': { val: deck[9],  rot: 0 },
          '1,0': { val: deck[10], rot: Math.PI / 2 },
          '0,0': { val: deck[11], rot: Math.PI / 2 }
        }, -Math.PI / 2),
        mat(null),            // [3] -Y  â€“ leer
        mat({                 // [4] +Z  = f0
          '2,0': { val: deck[0],  rot: Math.PI / 2 },
          '1,0': { val: deck[1],  rot: Math.PI / 2 },
          '0,1': { val: deck[2],  rot: Math.PI },
          '0,2': { val: deck[3],  rot: Math.PI }
        }),
        mat(null)             // [5] -Z  â€“ leer
      ];
      cube.material = cubeMaterial;
    };

    // GrÃ¼ne Markierung - Obere Ostkante
    const edgeGeometry = new THREE.CylinderGeometry(0.008, 0.008, cubeSize, 8);
    const edgeMaterial = new THREE.MeshStandardMaterial({
      color: 0x00ff00,
      metalness: 0.5,
      roughness: 0.3,
      emissive: 0x00ff00,
      emissiveIntensity: 0.3
    });
    
    const upperEastEdge = new THREE.Mesh(edgeGeometry, edgeMaterial);
    upperEastEdge.rotation.x = Math.PI / 2;
    upperEastEdge.position.set(0, 0.46875, 0.109375 + cubeSize / 2);
    kipGroup.add(upperEastEdge);

    // =========================
    // 2D-TIMING SYSTEM
    // =========================
    const FIXED_SPEED = 3;
    const TARGET_MIN = 0.55;
    const STEP_MAX = 0.80;
    let targetTimeMul = 1;

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function getTiming() {
      const v = FIXED_SPEED;
      const baseHold = Math.max(520, Math.round(2400 - v * 450));
      const baseKip = Math.max(160, Math.round(baseHold * 0.50));
      const baseW = baseHold;
      
      const mul = Math.max(TARGET_MIN, Math.min(1, targetTimeMul));
      
      const hold = Math.max(260, Math.round(baseHold * mul));
      const kip = Math.max(120, Math.round(baseKip * mul));
      const wfull = Math.max(260, Math.round(baseW * mul));
      
      return { holdMs: hold, kipMs: kip, wMs: wfull };
    }

    // =========================
    // UI ELEMENTS
    // =========================
    const hintText = document.getElementById('hintText');
    const countdown = document.getElementById('countdown');
    const actionButton = document.getElementById('actionButton');
    const backButton = document.getElementById('backButton');
    const kippButtons = document.getElementById('kippButtons');

    // =========================
    // SPIELLOGIK: Treffer-PrÃ¼fung
    // =========================
    let randColor = null;
    let randZahl = null;
    let topFace = 'f2'; // Anfangslage beim Spieleintritt

    function advanceTopFace() {
      const cw  = { f2: 'f0', f0: 'f1', f1: 'f2' };
      const ccw = { f2: 'f1', f1: 'f0', f0: 'f2' };
      topFace = (kippDirection === 'cw') ? cw[topFace] : ccw[topFace];
    }

    // Welche Nachbarfarbe hat jeder Slot pro Quadrant
    const SLOT_NEIGHBOR_COLORS = {
      0: { S1: 'blau',    S2: 'violett', S3: 'gruen',   S4: 'orange'  },
      1: { S1: 'orange',  S2: 'blau',    S3: 'violett', S4: 'gruen'   },
      2: { S1: 'gruen',   S2: 'orange',  S3: 'blau',    S4: 'violett' },
      3: { S1: 'violett', S2: 'gruen',   S3: 'orange',  S4: 'blau'    }
    };

    // 4 Farbfelder pro Quadrant (fÃ¼r Nicht-Treffer-Animation)
    const QUADRANT_COLORS = {
      0: ['Nord_C', 'Nord_D', 'West_5', 'West_6'],
      1: ['Nord_E', 'Nord_F', 'Ost_5',  'Ost_6'],
      2: ['SÃ¼d_E',  'SÃ¼d_F',  'Ost_7',  'Ost_8'],
      3: ['SÃ¼d_C',  'SÃ¼d_D',  'West_7', 'West_8']
    };

    // Material-Index pro Face (BoxGeometry: [+X,-X,+Y,-Y,+Z,-Z])
    const TOP_FACE_MAT_IDX = { f0: 4, f1: 1, f2: 2 };

    // DesÃ¤tturierte Versionen der Spielfarben fÃ¼r das KÃ¤rtchen
    const DESAT_COLORS = {
      violett: '#6b5a6b',
      blau:    '#5a6b7b',
      gruen:   '#5b7b6b',
      orange:  '#7b6b5a'
    };

    function checkTreffer() {
      const faceOffset = { f0: 0, f1: 4, f2: 8 };
      const off = faceOffset[topFace];
      const visible = { S1: deck[off], S2: deck[off+1], S3: deck[off+2], S4: deck[off+3] };

      // Ist randZahl sichtbar?
      let hitSlot = null;
      for (const [slot, val] of Object.entries(visible)) {
        if (val === randZahl) { hitSlot = slot; break; }
      }
      if (!hitSlot) return false;

      // Nachbarfarbe prÃ¼fen
      const neighborColor = SLOT_NEIGHBOR_COLORS[currentQuadrant][hitSlot];
      return neighborColor === randColor.name;
    }

    // Generische Animation eines Wertes Ã¼ber Zeit
    function animateVal(from, to, duration, onUpdate, onFinish) {
      const start = performance.now();
      function tick(now) {
        const t = Math.min((now - start) / duration, 1);
        const eased = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
        onUpdate(from + (to - from) * eased);
        if (t < 1) requestAnimationFrame(tick);
        else if (onFinish) onFinish();
      }
      requestAnimationFrame(tick);
    }

    let activeCardIdx = 0;
    const bereitsGetroffen = new Set(); // "zahl_farbe" Kombinationen die bereits Treffer waren

    function fillCard(idx) {
      const GAME_COLORS = [
        { name: 'violett', hex: '#a41b85' },
        { name: 'blau',    hex: '#006bb3' },
        { name: 'gruen',   hex: '#00a652' },
        { name: 'orange',  hex: '#e67814' }
      ];
      // Aktuelle WÃ¼rfelflÃ¤che: 4 Zahlen mit Nachbarfarben â†’ dÃ¼rfen nicht kommen
      function getCurrentWÃ¼rfelKombis() {
        const faceOffset = { f0: 0, f1: 4, f2: 8 };
        const off = faceOffset[topFace];
        const slots = ['S1', 'S2', 'S3', 'S4'];
        const kombi = new Set();
        slots.forEach((slot, i) => {
          const zahl = deck[off + i];
          const farbe = SLOT_NEIGHBOR_COLORS[currentQuadrant][slot];
          kombi.add(zahl + '_' + farbe);
        });
        return kombi;
      }

      const wurzelKombis = getCurrentWÃ¼rfelKombis();

      // Neue Kombination bis eine nicht ausgeschlossen ist
      do {
        randColor = GAME_COLORS[Math.floor(Math.random() * 4)];
        randZahl = Math.floor(Math.random() * 12) + 1;
      } while (bereitsGetroffen.has(randZahl + '_' + randColor.name) || wurzelKombis.has(randZahl + '_' + randColor.name));

      const card = gameCards[idx];
      card.ctx.fillStyle = randColor.hex;
      card.ctx.fillRect(0, 0, 85, 85);
      card.ctx.fillStyle = '#a08060';
      card.ctx.fillRect(0, 85, 85, 85);
      const displayText = randZahl + ((randZahl === 6 || randZahl === 9) ? '.' : '');
      card.ctx.fillStyle = '#2a1810';
      card.ctx.font = 'bold 56px Arial';
      card.ctx.textAlign = 'center';
      card.ctx.textBaseline = 'middle';
      card.ctx.fillText(displayText, 42, 128);
      card.texture.needsUpdate = true;
      card.mesh.scale.set(1, 1, 1);
    }

    function onRunde() {
      activeCardIdx++;
      if (activeCardIdx === 3) {
        // Nach drittem KÃ¤rtchen: WÃ¼rfel auf Ecke stelken, dann Pause-Phase
        setButtonsDisabled(true);
        document.getElementById('richtungButtons').classList.add('hidden');
        kippButtons.classList.add('hidden');
        // Pose vor der Animation speichern
        savedCubePosition = cube.position.clone();
        savedCubeQuaternion = cube.quaternion.clone();
        animateAufEcke().then(() => {
          startPausePhase();
        });
        return;
      }
      if (activeCardIdx < gameCards.length) {
        fillCard(activeCardIdx);
        setButtonsDisabled(false);
      }
    }


    function startPausePhase() {
      gamePhase = 'pause';
      pauseExiting = false;

      // KÃ¤rtchen faden aus (350ms)
      gameCards.forEach(c => {
        c.mesh.material.transparent = true;
        c.mesh.material.needsUpdate = true;
        c.mesh.material.opacity = 1;
      });
      shadowGradPlane.material.transparent = true;
      shadowGradPlane.material.needsUpdate = true;
      shadowGradPlane.material.opacity = 1;

      animateVal(1, 0, 350, (t) => {
        gameCards.forEach(c => { c.mesh.material.opacity = t; });
        shadowGradPlane.material.opacity = t;
      }, () => {
        // KÃ¤rtchen komplett aus
        gameCards.forEach(c => c.mesh.visible = false);
        shadowGradPlane.visible = false;
        pauseLights.forEach(l => l.visible = true);

        // Pause-Pivot auf der Ecke erstellen
        const cornerPos = new THREE.Vector3(0, 0, 0.109375);
        pausePivotGroup = new THREE.Group();
        pausePivotGroup.position.copy(cornerPos);
        kipGroup.add(pausePivotGroup);

        cube.updateMatrixWorld();
        const wp = new THREE.Vector3();
        cube.getWorldPosition(wp);
        const wq = new THREE.Quaternion();
        cube.getWorldQuaternion(wq);

        kipGroup.remove(cube);
        cube.position.copy(wp.clone().sub(cornerPos));
        cube.quaternion.copy(wq);
        pausePivotGroup.add(cube);

        pauseAlpha = 0;
        pauseBeta  = 0;
        pauseDragActive = false;

        // UI faden ein
        hintText.textContent = 'SCHAUEN & MERKEN';
        hintText.style.opacity = '0';
        hintText.style.display = 'block';
        actionButton.textContent = 'weiter';
        actionButton.style.opacity = '0';
        actionButton.style.display = 'block';
        countdown.textContent = '0';
        countdown.style.opacity = '0';
        countdown.style.display = 'block';

        // requestAnimationFrame damit display:block erstmal greift
        requestAnimationFrame(() => {
          hintText.style.transition = 'opacity 0.4s ease';
          actionButton.style.transition = 'opacity 0.4s ease';
          countdown.style.transition = 'opacity 0.4s ease';
          hintText.style.opacity = '1';
          actionButton.style.opacity = '1';
          countdown.style.opacity = '1';
        });

        // ZÃ¤hler bis 30
        let elapsed = 0;
        pauseTimerRef = setInterval(() => {
          elapsed++;
          countdown.textContent = elapsed;
          if (elapsed >= 30) {
            clearInterval(pauseTimerRef);
            pauseTimerRef = null;
            endPausePhase();
          }
        }, 1000);
      });
    }

    function endPausePhase() {
      if (pauseExiting) return;
      pauseExiting = true;
      pauseSpringRunning = false;
      pauseDragActive = false;
      if (pauseTimerRef) { clearInterval(pauseTimerRef); pauseTimerRef = null; }

      // UI faden aus
      hintText.style.transition = 'opacity 0.35s ease';
      actionButton.style.transition = 'opacity 0.35s ease';
      countdown.style.transition = 'opacity 0.35s ease';
      hintText.style.opacity = '0';
      actionButton.style.opacity = '0';
      countdown.style.opacity = '0';
      setTimeout(() => {
        hintText.style.display = 'none';
        actionButton.style.display = 'none';
        countdown.style.display = 'none';
      }, 350);

      // Schritt 1: Aufrichten von aktueller Position auf senkrecht (alpha=0, beta=0)
      const startAlpha = pauseAlpha;
      const startBeta  = pauseBeta;
      const aufrichtDur = 600;
      const aufrichtStart = Date.now();

      function animateAufrichten() {
        const elapsed = Date.now() - aufrichtStart;
        const progress = Math.min(elapsed / aufrichtDur, 1);
        const eased = progress < 0.5
          ? 2 * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;

        pauseAlpha = startAlpha * (1 - eased);
        pauseBeta  = startBeta  * (1 - eased);
        if (pausePivotGroup) pausePivotGroup.rotation.set(pauseAlpha, pauseBeta, 0, 'YXZ');

        if (progress < 1) {
          requestAnimationFrame(animateAufrichten);
        } else {
          pauseAlpha = 0;
          pauseBeta  = 0;
          if (pausePivotGroup) pausePivotGroup.rotation.set(0, 0, 0, 'YXZ');
          // Schritt 2: Inverse aufEcke â€” zurÃ¼ck auf letzte Spielposition
          animateInverseAufEcke();
        }
      }
      animateAufrichten();
    }

    function animateInverseAufEcke() {
      const duration = 1200;
      const startTime = Date.now();
      const inverseQuat = aufEckeTargetQuat.clone().invert();

      function animateZurÃ¼ck() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = progress < 0.5
          ? 2 * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;

        const currentQuat = new THREE.Quaternion().slerp(inverseQuat, eased);
        if (pausePivotGroup) pausePivotGroup.quaternion.copy(currentQuat);

        if (progress < 1) {
          requestAnimationFrame(animateZurÃ¼ck);
        } else {
          finishPauseToSpiel();
        }
      }
      animateZurÃ¼ck();
    }

    async function animateAufEcke() {
      const cornerPos = new THREE.Vector3(0, 0, 0.109375); // Die feste Ecke
      const duration = 1200;

      // Cube aus kipGroup nehmen, in pivotGroup bei der Ecke platzieren
      const pivotGroup = new THREE.Group();
      pivotGroup.position.copy(cornerPos);
      kipGroup.add(pivotGroup);

      cube.updateMatrixWorld();
      const cubeWorldPos = new THREE.Vector3();
      cube.getWorldPosition(cubeWorldPos);
      const cubeWorldQuat = new THREE.Quaternion();
      cube.getWorldQuaternion(cubeWorldQuat);

      kipGroup.remove(cube);
      cube.position.copy(cubeWorldPos.clone().sub(cornerPos));
      cube.quaternion.copy(cubeWorldQuat);
      pivotGroup.add(cube);

      // Ziel-Rotation: Vektor von Ecke zum WÃ¼rfelmittelpunkt soll nach +Y zeigen
      const relativePos = cube.position.clone().normalize();
      const targetDir = new THREE.Vector3(0, 1, 0);
      const targetQuat = new THREE.Quaternion().setFromUnitVectors(relativePos, targetDir);
      aufEckeTargetQuat = targetQuat.clone();

      const startTime = Date.now();

      return new Promise((resolve) => {
        function animate() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);
          const eased = progress < 0.5
            ? 2 * progress * progress
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;

          const currentQuat = new THREE.Quaternion().copy(new THREE.Quaternion()).slerp(targetQuat, eased);
          pivotGroup.quaternion.copy(currentQuat);

          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            // Cleanup: wie finalizeKipp
            cube.updateMatrixWorld();
            const newWorldPos = new THREE.Vector3();
            cube.getWorldPosition(newWorldPos);
            const newWorldQuat = new THREE.Quaternion();
            cube.getWorldQuaternion(newWorldQuat);

            pivotGroup.remove(cube);
            kipGroup.remove(pivotGroup);

            cube.position.copy(newWorldPos);
            cube.quaternion.copy(newWorldQuat);
            kipGroup.add(cube);

            resolve();
          }
        }
        animate();
      });
    }

    function animateTreffer() {
      const card = gameCards[activeCardIdx];
      const mesh = card.mesh;
      const origScale = 1.0;
      const targetScale = 1.7;

      // 1. KÃ¤rtchen groÃŸ machen
      animateVal(origScale, targetScale, 350, (s) => {
        mesh.scale.set(s, s, s);
      }, () => {
        // 2. GroÃŸ bleiben fÃ¼r 2 Sekunden
        setTimeout(() => {
          // 3. ZurÃ¼ck auf NormalgrÃ¶ÃŸe
          animateVal(targetScale, origScale, 350, (s) => {
            mesh.scale.set(s, s, s);
          }, () => {
            onRunde();
          });
        }, 2000);
      });
    }

    function animateNichtTreffer() {
      // 1. WÃ¼rfel-Oberseite langsam dunkelgrau und zurÃ¼ck (2s)
      const matIdx = TOP_FACE_MAT_IDX[topFace];
      const topMat = cube.material[matIdx];
      const origColor = topMat.color.clone();
      // Phase 1: normal â†’ dunkelgrau (1s)
      animateVal(0, 1, 1000, (t) => {
        topMat.color.copy(origColor).lerp(new THREE.Color(0x303030), t);
      }, () => {
        // Phase 2: dunkelgrau â†’ normal (1s)
        animateVal(0, 1, 1000, (t) => {
          topMat.color.copy(new THREE.Color(0x303030)).lerp(origColor, t);
        }, () => {
          onRunde();
        });
      });

      // 2. 4 Farbfelder des Quadranten kurz transparent
      const keys = QUADRANT_COLORS[currentQuadrant];
      keys.forEach(key => {
        const m = colorSquareMeshes[key];
        if (!m) return;
        m.material.transparent = true;
        m.material.opacity = 0.12;
        setTimeout(() => {
          animateVal(0.12, 1.0, 350, (op) => { m.material.opacity = op; });
        }, 250);
      });

      // 3. KÃ¤rtchen desÃ¤tturieren
      const card = gameCards[activeCardIdx];
      card.ctx.fillStyle = DESAT_COLORS[randColor.name];
      card.ctx.fillRect(0, 0, 85, 85);
      card.ctx.fillStyle = '#807868';
      card.ctx.fillRect(0, 85, 85, 85);
      const displayText = randZahl + ((randZahl === 6 || randZahl === 9) ? '.' : '');
      card.ctx.fillStyle = '#5a5a5a';
      card.ctx.font = 'bold 56px Arial';
      card.ctx.textAlign = 'center';
      card.ctx.textBaseline = 'middle';
      card.ctx.fillText(displayText, 42, 128);
      card.texture.needsUpdate = true;
    }

    let gamePhase = 'kippen'; // Startet direkt in Phase 2
    let currentMode = 'kanten'; // Startet direkt im Kanten-Modus
    let kippCount = 0;
    let countdownTimer = null;

    // UI fÃ¼r Phase 2 initialisieren
    hintText.textContent = 'KIPPE UND MERKE!';
    actionButton.textContent = 'weiter';
    
    function startCountdown(onFinish) {
      let elapsed = 0;
      countdown.textContent = elapsed;
      countdown.style.display = 'block';
      
      countdownTimer = setInterval(() => {
        elapsed++;
        countdown.textContent = elapsed;
        if (elapsed >= 60) {
          stopCountdown();
          if (onFinish) onFinish();
        }
      }, 1000);
    }
    
    function stopCountdown() {
      if (countdownTimer) {
        clearInterval(countdownTimer);
        countdownTimer = null;
      }
      countdown.style.display = 'none';
    }
    
    // ZÃ¤hler anzeigen aber noch nicht starten (startet bei erster BerÃ¼hrung)
    countdown.textContent = 0;
    countdown.style.display = 'block';
    let timerStarted = false;
    
    function phaseKippenToSpielen() {
      gamePhase = 'spielen';
      currentMode = 'kanten';
      
      // WÃ¼rfel auf Startlage resetten (Q3, f2 oben)
      cube.position.set(-offset, offset, 0.109375 + offset);
      cube.rotation.set(0, 0, 0);
      currentQuadrant = 3;
      topFace = 'f2';

      // Countdown STOPPEN
      stopCountdown();
      
      // UI umschalten
      hintText.style.display = 'none';
      actionButton.style.display = 'none';
      document.getElementById('placeholderRow').classList.add('hidden'); // wird durch Three.js KÃ¤rtchen ersetzt
      document.getElementById('richtungButtons').classList.remove('hidden');
      kippButtons.classList.remove('hidden');

      // Random Farbe + Zahl generieren
      const GAME_COLORS = [
        { name: 'violett', hex: '#a41b85' },
        { name: 'blau',    hex: '#006bb3' },
        { name: 'gruen',   hex: '#00a652' },
        { name: 'orange',  hex: '#e67814' }
      ];
      randColor = GAME_COLORS[Math.floor(Math.random() * 4)];
      randZahl = Math.floor(Math.random() * 12) + 1;

      // KÃ¤rtchen sichtbar machen
      gameCards.forEach(c => c.mesh.visible = true);
      shadowGradPlane.visible = true;

      // Erstes KÃ¤rtchen befÃ¼llen
      activeCardIdx = 0;
      bereitsGetroffen.clear();
      fillCard(0);
      setButtonsDisabled(false);
    }
    
    actionButton.addEventListener('click', () => {
      if (gamePhase === 'kippen') {
        phaseKippenToSpielen();
      } else if (gamePhase === 'pause') {
        endPausePhase();
      }
    });

    backButton.addEventListener('click', () => {
      if (gamePhase !== 'kippen' && gamePhase !== 'spielen') return;
      gamePhase = 'kippen'; // ZurÃ¼ck zu Phase 2
      currentMode = 'kanten';
      kippCount = 0;
      
      // UI zurÃ¼cksetzen zu Phase 2
      hintText.style.display = 'block';
      hintText.textContent = 'KIPPE UND MERKE!';
      actionButton.textContent = 'weiter';
      actionButton.style.display = 'block';
      actionButton.classList.remove('pulse');
      kippButtons.classList.add('hidden');
      document.getElementById('placeholderRow').classList.add('hidden');
      document.getElementById('richtungButtons').classList.add('hidden');
      
      // KÃ¤rtchen verstecken
      gameCards.forEach(c => c.mesh.visible = false);
      shadowGradPlane.visible = false;
      
      // WÃ¼rfel zurÃ¼cksetzen zu Q3
      cube.position.set(-offset, offset, 0.109375 + offset);
      cube.rotation.set(0, 0, 0);
      currentQuadrant = 3;
      topFace = 'f2'; // Anfangslage zurÃ¼cksetzen
      
      // Countdown neu starten fÃ¼r Phase 2
      timerStarted = false;
      countdown.textContent = 0;
      countdown.style.display = 'block';
      
    });

    // =========================
    // WÃœRFEL-KIPPMECHANIK
    // =========================
    // DRAG-KIPP-STEUERUNG (Phase 2)
    // =========================
    let isSwiping = false;
    let swipeStartX = 0;
    let swipeStartY = 0;
    let isAnimating = false;
    let currentQuadrant = 3;

    // Drag-State
    let dragActive = false;
    let dragPivotGroup = null;
    let dragAxis = null;
    let dragTargetSign = 0;
    let dragToQ = 0;
    let dragCurrentAngle = 0;
    const DRAG_SENSITIVITY = 150; // px fÃ¼r volle 90Â°

    // =========================
    // PAUSE-PHASE: Ecke-Drehinteraktion
    // =========================
    // 8 Ecken des WÃ¼rfels nach body-diagonal-Rotation (Pivot = Ecke, vorberechnet)
    const ECKE_CORNERS = [
      [ 0.000000,  0.000000,  0.000000],
      [ 0.369691,  0.270633, -0.099059],
      [-0.270633,  0.270633, -0.270633],
      [-0.099059,  0.270633,  0.369691],
      [ 0.099059,  0.541266, -0.369691],
      [ 0.270633,  0.541266,  0.270633],
      [-0.369691,  0.541266,  0.099059],
      [ 0.000000,  0.811899,  0.000000]
    ];
    // Frame-Grenzen relativ zum Pivot (0, 0, 0.109375)
    const PAUSE_LIMIT_S =  0.4705;   // sÃ¼d  (wallInnerSouth - pivotZ)
    const PAUSE_LIMIT_N =  0.46875;  // nord
    const PAUSE_LIMIT_E =  0.46875;  // ost
    const PAUSE_LIMIT_W =  0.46875;  // west

    function isPausePoseValid(alpha, beta) {
      const ca = Math.cos(alpha), sa = Math.sin(alpha);
      const cb = Math.cos(beta),  sb = Math.sin(beta);
      for (const [x, y, z] of ECKE_CORNERS) {
        // Ry(Î²) zuerst
        const x1 =  x * cb + z * sb;
        const z1 = -x * sb + z * cb;
        // Rx(Î±) danach
        const z2 = y * sa + z1 * ca;
        // x Ã¤ndert sich durch Rx nicht â†’ x1 bleiben
        if ( x1 > PAUSE_LIMIT_E || -x1 > PAUSE_LIMIT_W) return false;
        if ( z2 > PAUSE_LIMIT_S || -z2 > PAUSE_LIMIT_N) return false;
      }
      return true;
    }

    function getMaxBeta(alpha, sign) {
      // sign: +1 oder -1
      if (!isPausePoseValid(alpha, 0)) return 0;
      let lo = 0, hi = Math.PI;
      for (let i = 0; i < 16; i++) {
        const mid = (lo + hi) / 2;
        if (isPausePoseValid(alpha, sign * mid)) lo = mid; else hi = mid;
      }
      return lo;
    }

    function getMaxAlpha(beta) {
      if (!isPausePoseValid(0, beta)) return 0;
      let lo = 0, hi = Math.PI / 6; // 30Â° als obere Suche
      for (let i = 0; i < 20; i++) {
        const mid = (lo + hi) / 2;
        if (isPausePoseValid(mid, beta)) lo = mid; else hi = mid;
      }
      return lo;
    }

    let pausePivotGroup = null;
    let aufEckeTargetQuat = null;
    let pauseSpringRunning = false;
    let pauseTimerRef = null;
    let pauseExiting = false;
    let savedCubePosition = null;  // Position vor animateAufEcke
    let savedCubeQuaternion = null; // Quaternion vor animateAufEcke
    let pauseAlpha = 0;
    let pauseBeta  = 0;
    let pauseDragActive = false;
    let pauseDragStartX = 0;
    let pauseDragStartY = 0;
    let pauseDragStartAlpha = 0;
    let pauseDragStartBeta  = 0;
    const PAUSE_SENSITIVITY = 200; // px fÃ¼r ~30Â°

    function getKippConfig(direction) {
      const configs = {
        'north':         { pivotPoint: new THREE.Vector3(-0.234375, 0, 0.109375), axis: 'x', targetRotation: -Math.PI/2, toQ: 0 },
        'south':         { pivotPoint: new THREE.Vector3(-0.234375, 0, 0.109375), axis: 'x', targetRotation:  Math.PI/2, toQ: 3 },
        'east':          { pivotPoint: new THREE.Vector3(0, 0, 0.343125),         axis: 'z', targetRotation: -Math.PI/2, toQ: 1 },
        'west':          { pivotPoint: new THREE.Vector3(0, 0, 0.343125),         axis: 'z', targetRotation:  Math.PI/2, toQ: 0 },
        'south_from_q1': { pivotPoint: new THREE.Vector3(0.234375, 0, 0.109375),  axis: 'x', targetRotation:  Math.PI/2, toQ: 2 },
        'north_from_q2': { pivotPoint: new THREE.Vector3(0.234375, 0, 0.109375),  axis: 'x', targetRotation: -Math.PI/2, toQ: 1 },
        'west_from_q2':  { pivotPoint: new THREE.Vector3(0, 0, 0.343125),         axis: 'z', targetRotation:  Math.PI/2, toQ: 3 },
        'east_from_q3':  { pivotPoint: new THREE.Vector3(0, 0, 0.343125),         axis: 'z', targetRotation: -Math.PI/2, toQ: 2 }
      };
      return configs[direction];
    }

    function getValidDirection(deltaX, deltaY) {
      if (Math.abs(deltaY) >= Math.abs(deltaX)) {
        if (deltaY < 0) {
          if (currentQuadrant === 3) return 'north';
          if (currentQuadrant === 2) return 'north_from_q2';
        } else {
          if (currentQuadrant === 0) return 'south';
          if (currentQuadrant === 1) return 'south_from_q1';
        }
      } else {
        if (deltaX > 0) {
          if (currentQuadrant === 0) return 'east';
          if (currentQuadrant === 3) return 'east_from_q3';
        } else {
          if (currentQuadrant === 1) return 'west';
          if (currentQuadrant === 2) return 'west_from_q2';
        }
      }
      return null;
    }


    renderer.domElement.addEventListener('touchstart', (e) => {
      if (gamePhase === 'pause' && pausePivotGroup) {
        e.preventDefault();
        const touch = e.touches[0];
        pauseDragStartX = touch.clientX;
        pauseDragStartY = touch.clientY;
        pauseDragStartAlpha = pauseAlpha;
        pauseDragStartBeta  = pauseBeta;
        pauseDragActive = true;
        return;
      }
      if (currentMode === 'kanten' && gamePhase === 'kippen') {
        if (isAnimating) return;
        e.preventDefault();
        // ZÃ¤hler beim ersten Kipp starten
        if (!timerStarted) {
          timerStarted = true;
          startCountdown(() => {
            if (gamePhase === 'kippen') {
              phaseKippenToSpielen();
            }
          });
        }
        const touch = e.touches[0];
        swipeStartX = touch.clientX;
        swipeStartY = touch.clientY;
        isSwiping = true;
        dragActive = false;
      }
    });

    renderer.domElement.addEventListener('touchmove', (e) => {
      if (gamePhase === 'pause' && pauseDragActive && pausePivotGroup) {
        e.preventDefault();
        const touch = e.touches[0];
        const dx = touch.clientX - pauseDragStartX;
        const dy = touch.clientY - pauseDragStartY;

        // Î²: X-Drag â†’ Y-Rotation (links = positiv)
        let newBeta  = pauseDragStartBeta  + (dx / PAUSE_SENSITIVITY) * Math.PI;
        // Î±: Y-Drag nach unten â†’ Tilt nach SÃ¼den
        let newAlpha = pauseDragStartAlpha + (dy / PAUSE_SENSITIVITY) * (Math.PI / 3);
        newAlpha = Math.max(0, newAlpha);

        // Alpha clampen bei gegebenem Beta
        const maxA = getMaxAlpha(newBeta);
        newAlpha = Math.min(newAlpha, maxA);

        // Beta clampen bei gegebenem Alpha
        if (!isPausePoseValid(newAlpha, newBeta)) {
          const sign = newBeta >= 0 ? 1 : -1;
          const maxB = getMaxBeta(newAlpha, sign);
          newBeta = sign * maxB;
        }

        pauseAlpha = newAlpha;
        pauseBeta  = newBeta;

        // Euler 'YXZ': erst Ry(Î²), dann Rx(Î±)
        pausePivotGroup.rotation.set(pauseAlpha, pauseBeta, 0, 'YXZ');
        return;
      }
      if (!isSwiping || isAnimating || gamePhase !== 'kippen' || currentMode !== 'kanten') return;
      e.preventDefault();

      const touch = e.touches[0];
      const deltaX = touch.clientX - swipeStartX;
      const deltaY = touch.clientY - swipeStartY;

      // Warte auf minimale Bewegung bevor Richtung bestimmt wird
      if (!dragActive) {
        if (Math.max(Math.abs(deltaX), Math.abs(deltaY)) < 8) return;

        const direction = getValidDirection(deltaX, deltaY);
        if (!direction) { isSwiping = false; return; }

        const config = getKippConfig(direction);
        dragAxis = config.axis;
        dragTargetSign = config.targetRotation > 0 ? 1 : -1;
        dragToQ = config.toQ;

        // Pivot-Gruppe setup
        dragPivotGroup = new THREE.Group();
        dragPivotGroup.position.copy(config.pivotPoint);
        kipGroup.add(dragPivotGroup);

        cube.updateMatrixWorld();
        const cubeWorldPos = new THREE.Vector3();
        cube.getWorldPosition(cubeWorldPos);
        kipGroup.remove(cube);
        cube.position.copy(cubeWorldPos.clone().sub(config.pivotPoint));
        dragPivotGroup.add(cube);

        dragActive = true;
        dragCurrentAngle = 0;
      }

      // Rotation live berechnen
      // X-Achse: deltaY direkt (oben neg, unten pos)
      // Z-Achse: -deltaX (rechts pos wird neg Rotation)
      const relevantDelta = (dragAxis === 'x') ? deltaY : -deltaX;
      let angle = (relevantDelta / DRAG_SENSITIVITY) * (Math.PI / 2);

      // Clamp zwischen 0 und targetRotation
      if (dragTargetSign > 0) {
        angle = Math.max(0, Math.min(Math.PI / 2, angle));
      } else {
        angle = Math.min(0, Math.max(-Math.PI / 2, angle));
      }

      dragCurrentAngle = angle;

      if (dragAxis === 'x') {
        dragPivotGroup.rotation.x = dragCurrentAngle;
      } else {
        dragPivotGroup.rotation.z = dragCurrentAngle;
      }
    });

    function finishPauseToSpiel() {
      // PivotGroup auflÃ¶sen
      if (pausePivotGroup) {
        pausePivotGroup.remove(cube);
        kipGroup.remove(pausePivotGroup);
        pausePivotGroup = null;
        kipGroup.add(cube);
      }

      // Gespeicherter Zustand vor der Pause â€” immer wiederherstellen
      cube.position.copy(savedCubePosition);
      cube.quaternion.copy(savedCubeQuaternion);

      gamePhase = 'spielen';
      document.getElementById('richtungButtons').classList.remove('hidden');
      kippButtons.classList.remove('hidden');

      // KÃ¤rtchen befÃ¼llen + sichtbar machen
      pauseLights.forEach(l => l.visible = false);
      shadowGradPlane.visible = true;
      shadowGradPlane.material.opacity = 1;
      gameCards.forEach((c, i) => {
        c.mesh.visible = (i <= activeCardIdx);
        c.mesh.material.opacity = 1;
      });
      fillCard(activeCardIdx);
      setButtonsDisabled(false);
    }

    renderer.domElement.addEventListener('touchend', () => {
      if (gamePhase === 'pause') {
        pauseDragActive = false;
        return;
      }
      isSwiping = false;
      if (!dragActive) return;

      // Tipping-Point bei 45Â° (PI/4)
      const absAngle = Math.abs(dragCurrentAngle);
      let targetAngle, finalQ;

      if (absAngle > Math.PI / 4) {
        targetAngle = dragTargetSign * Math.PI / 2; // Kippen
        finalQ = dragToQ;
      } else {
        targetAngle = 0; // ZurÃ¼ckfallen
        finalQ = currentQuadrant;
      }

      // Schwerkraft-Fall-Animation
      isAnimating = true;
      const startAngle = dragCurrentAngle;
      const angleDiff = targetAngle - startAngle;
      const fallDuration = Math.max(150, Math.abs(angleDiff) / (Math.PI / 2) * 420);
      const startTime = Date.now();

      function animateFall() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / fallDuration, 1);

        // Ease-in (tÂ²) = Schwerkraft-Beschleunigung
        const eased = progress * progress;
        const currentAngle = startAngle + angleDiff * eased;

        if (dragAxis === 'x') {
          dragPivotGroup.rotation.x = currentAngle;
        } else {
          dragPivotGroup.rotation.z = currentAngle;
        }

        if (progress < 1) {
          requestAnimationFrame(animateFall);
        } else {
          if (targetAngle === 0) {
            // ZurÃ¼ckgefallen: WÃ¼rfel zurÃ¼ck in kipGroup
            cube.updateMatrixWorld();
            const newPos = new THREE.Vector3();
            cube.getWorldPosition(newPos);
            const newQuat = new THREE.Quaternion();
            cube.getWorldQuaternion(newQuat);
            dragPivotGroup.remove(cube);
            kipGroup.remove(dragPivotGroup);
            cube.position.copy(newPos);
            cube.quaternion.copy(newQuat);
            kipGroup.add(cube);
          } else {
            // Gekippt: finalisieren
            finalizeKipp(finalQ, null);
          }
          dragActive = false;
          dragPivotGroup = null;
          isAnimating = false;
        }
      }

      animateFall();
    });
    
    async function performKipp(direction, duration = 800) {
      if (isAnimating) return;
      isAnimating = true;
      
      let pivotPoint, axis, targetRotation, fromQ, toQ;
      
      if (direction === 'north') {
        pivotPoint = new THREE.Vector3(-0.234375, 0, 0.109375);
        axis = 'x';
        targetRotation = -Math.PI / 2;
        fromQ = 3;
        toQ = 0;
      } else if (direction === 'south') {
        pivotPoint = new THREE.Vector3(-0.234375, 0, 0.109375);
        axis = 'x';
        targetRotation = Math.PI / 2;
        fromQ = 0;
        toQ = 3;
      } else if (direction === 'east') {
        pivotPoint = new THREE.Vector3(0, 0, 0.109375 + 0.234375);
        axis = 'z';
        targetRotation = -Math.PI / 2;
        fromQ = 0;
        toQ = 1;
      } else if (direction === 'west') {
        pivotPoint = new THREE.Vector3(0, 0, 0.109375 + 0.234375);
        axis = 'z';
        targetRotation = Math.PI / 2;
        fromQ = 1;
        toQ = 0;
      } else if (direction === 'south_from_q1') {
        pivotPoint = new THREE.Vector3(0.234375, 0, 0.109375);
        axis = 'x';
        targetRotation = Math.PI / 2;
        fromQ = 1;
        toQ = 2;
      } else if (direction === 'north_from_q2') {
        pivotPoint = new THREE.Vector3(0.234375, 0, 0.109375);
        axis = 'x';
        targetRotation = -Math.PI / 2;
        fromQ = 2;
        toQ = 1;
      } else if (direction === 'west_from_q2') {
        pivotPoint = new THREE.Vector3(0, 0, 0.109375 + 0.234375);
        axis = 'z';
        targetRotation = Math.PI / 2;
        fromQ = 2;
        toQ = 3;
      } else if (direction === 'east_from_q3') {
        pivotPoint = new THREE.Vector3(0, 0, 0.109375 + 0.234375);
        axis = 'z';
        targetRotation = -Math.PI / 2;
        fromQ = 3;
        toQ = 2;
      }
      
      const pivotGroup = new THREE.Group();
      pivotGroup.position.copy(pivotPoint);
      kipGroup.add(pivotGroup);
      
      cube.updateMatrixWorld();
      const cubeWorldPos = new THREE.Vector3();
      cube.getWorldPosition(cubeWorldPos);
      
      kipGroup.remove(cube);
      
      const relativePos = cubeWorldPos.clone().sub(pivotPoint);
      cube.position.copy(relativePos);
      pivotGroup.add(cube);
      
      const startTime = Date.now();
      
      return new Promise((resolve) => {
        function animate() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);
          
          const eased = progress < 0.5 
            ? 2 * progress * progress 
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
          
          if (axis === 'x') {
            pivotGroup.rotation.x = eased * targetRotation;
          } else {
            pivotGroup.rotation.z = eased * targetRotation;
          }
          
          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            finalizeKipp(toQ, resolve);
          }
        }
        
        animate();
      });
    }
    
    function finalizeKipp(newQ, callback) {
      cube.updateMatrixWorld();
      const newWorldPos = new THREE.Vector3();
      cube.getWorldPosition(newWorldPos);
      const newWorldQuat = new THREE.Quaternion();
      cube.getWorldQuaternion(newWorldQuat);
      
      const parent = cube.parent;
      if (parent && parent.parent) {
        parent.parent.remove(parent);
      }
      
      cube.position.copy(newWorldPos);
      cube.quaternion.copy(newWorldQuat);
      kipGroup.add(cube);
      
      currentQuadrant = newQ;
      isAnimating = false;
      if (callback) callback();
    }

    // =========================
    // KIPP-SEQUENZ mit 2D-Timing
    // =========================
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function runKippSequence(steps) {
      if (isAnimating) return;
      
      const T = getTiming();
      const kipFactor = 1;
      
      
      for (let i = 0; i < steps; i++) {
        const tStep = (steps <= 1) ? 0 : (i / (steps - 1));
        const stepMul = lerp(1.0, STEP_MAX, tStep);
        
        const kipTime = Math.max(40, Math.round(T.kipMs * kipFactor * stepMul));
        const holdTime = Math.max(40, Math.round(T.wMs * stepMul));
        
        
        let direction;
        if (kippDirection === 'cw') {
          if (currentQuadrant === 0) direction = 'east';
          else if (currentQuadrant === 1) direction = 'south_from_q1';
          else if (currentQuadrant === 2) direction = 'west_from_q2';
          else direction = 'north'; // Q3
        } else {
          // CCW: umgekehrte Reihenfolge
          if (currentQuadrant === 0) direction = 'south';
          else if (currentQuadrant === 1) direction = 'west';
          else if (currentQuadrant === 2) direction = 'north_from_q2';
          else direction = 'east_from_q3'; // Q3
        }
        
        await performKipp(direction, kipTime);
        advanceTopFace();
        await sleep(holdTime);
      }
    }

    // =========================
    // CW/CCW Richtung
    let kippDirection = 'cw';
    const cwBtn = document.getElementById('cwBtn');
    const ccwBtn = document.getElementById('ccwBtn');

    function updateRichtungButtons() {
      if (kippDirection === 'cw') {
        cwBtn.style.background = 'linear-gradient(180deg,#4a3e28 0%,#3a2e1c 100%)';
        cwBtn.style.color = '#c0b870';
        cwBtn.style.borderColor = '#d4b48c';
        cwBtn.style.boxShadow = '0 0 8px rgba(212,180,140,0.6), 0 0 20px rgba(212,180,140,0.35)';
        ccwBtn.style.background = 'linear-gradient(180deg,#404040 0%,#303030 100%)';
        ccwBtn.style.color = '#c0b8a8';
        ccwBtn.style.borderColor = '#808080';
        ccwBtn.style.boxShadow = '';
      } else {
        ccwBtn.style.background = 'linear-gradient(180deg,#4a3e28 0%,#3a2e1c 100%)';
        ccwBtn.style.color = '#c0b870';
        ccwBtn.style.borderColor = '#d4b48c';
        ccwBtn.style.boxShadow = '0 0 8px rgba(212,180,140,0.6), 0 0 20px rgba(212,180,140,0.35)';
        cwBtn.style.background = 'linear-gradient(180deg,#404040 0%,#303030 100%)';
        cwBtn.style.color = '#c0b8a8';
        cwBtn.style.borderColor = '#808080';
        cwBtn.style.boxShadow = '';
      }
    }
    // CW/CCW werden durch triggerKipp weiter unten gehandelt

    // =========================
    // Zwei-Schritt Ablauf: erst Zahl wÃ¤hlen, dann Richtung
    // =========================
    let selectedAnzahl = null;

    function setButtonsDisabled(disabled) {
      document.querySelectorAll('.kippBtn').forEach(btn => {
        btn.disabled = disabled;
        btn.classList.remove('pulsing');
        if (!disabled) {
          btn.style.background = btn.id === 'cwBtn' || btn.id === 'ccwBtn'
            ? 'linear-gradient(180deg,#404040 0%,#303030 100%)'
            : 'linear-gradient(180deg,#606060 0%,#404040 100%)';
          btn.style.color = '#c0b8a8';
          btn.style.borderColor = '#808080';
          btn.style.boxShadow = '';
        }
      });
      if (!disabled) startZahlWarten();
    }

    function pulseZahlenButtons(on) {
      document.querySelectorAll('.kippBtn[data-anzahl]').forEach(btn => {
        if (on) btn.classList.add('pulsing');
        else btn.classList.remove('pulsing');
      });
    }
    function pulseRichtungButtons(on) {
      if (on) { cwBtn.classList.add('pulsing'); ccwBtn.classList.add('pulsing'); }
      else    { cwBtn.classList.remove('pulsing'); ccwBtn.classList.remove('pulsing'); }
    }

    function startZahlWarten() {
      selectedAnzahl = null;
      pulseZahlenButtons(true);
      pulseRichtungButtons(false);
      // Richtungsbuttons neutral (keine Hervorhebuung)
      cwBtn.style.background = 'linear-gradient(180deg,#404040 0%,#303030 100%)';
      cwBtn.style.color = '#c0b8a8';
      cwBtn.style.borderColor = '#808080';
      cwBtn.style.boxShadow = '';
      ccwBtn.style.background = 'linear-gradient(180deg,#404040 0%,#303030 100%)';
      ccwBtn.style.color = '#c0b8a8';
      ccwBtn.style.borderColor = '#808080';
      ccwBtn.style.boxShadow = '';
    }

    function startRichtungWarten() {
      pulseZahlenButtons(false);
      pulseRichtungButtons(true);
    }

    function stopAllenPulse() {
      pulseZahlenButtons(false);
      pulseRichtungButtons(false);
    }

    // Zahl-Buttons: nur Zahl speichern, kein Kipp
    document.querySelectorAll('.kippBtn[data-anzahl]').forEach(btn => {
      btn.addEventListener('click', () => {
        if (gamePhase !== 'spielen') return;
        if (selectedAnzahl !== null) return; // schon eine Zahl gewÃ¤hlt

        selectedAnzahl = parseInt(btn.dataset.anzahl);

        // GewÃ¤hlte Zahl hervorheben
        btn.style.background = 'linear-gradient(180deg,#4a3e28 0%,#3a2e1c 100%)';
        btn.style.color = '#c0b870';
        btn.style.borderColor = '#d4b48c';
        btn.style.boxShadow = '0 0 8px rgba(212,180,140,0.6), 0 0 20px rgba(212,180,140,0.35)';

        startRichtungWarten();
      });
    });

    // CW/CCW: wenn Zahl schon gewÃ¤hlt â†’ Kipp starten
    async function triggerKipp(direction) {
      if (gamePhase !== 'spielen') return;
      if (selectedAnzahl === null) return; // noch keine Zahl â†’ nur Richtung anzeigen

      const anzahl = selectedAnzahl;
      stopAllenPulse();
      setButtonsDisabled(true);

      kippDirection = direction;
      updateRichtungButtons();

      // KÃ¤rtchen auf Originalfarben zurÃ¼cksetzen
      const card = gameCards[activeCardIdx];
      card.ctx.fillStyle = randColor.hex;
      card.ctx.fillRect(0, 0, 85, 85);
      card.ctx.fillStyle = '#a08060';
      card.ctx.fillRect(0, 85, 85, 85);
      const displayText = randZahl + ((randZahl === 6 || randZahl === 9) ? '.' : '');
      card.ctx.fillStyle = '#2a1810';
      card.ctx.font = 'bold 56px Arial';
      card.ctx.textAlign = 'center';
      card.ctx.textBaseline = 'middle';
      card.ctx.fillText(displayText, 42, 128);
      card.texture.needsUpdate = true;
      card.mesh.scale.set(1, 1, 1);
      card.mesh.material.opacity = 1.0;

      await runKippSequence(anzahl);

      // Treffer-PrÃ¼fung
      const treffer = checkTreffer();
      if (treffer) {
        bereitsGetroffen.add(randZahl + '_' + randColor.name);
        animateTreffer();
      } else {
        animateNichtTreffer();
      }
    }

    cwBtn.addEventListener('click', () => triggerKipp('cw'));
    ccwBtn.addEventListener('click', () => triggerKipp('ccw'));

    // Animation loop
    function renderLoop() {
      requestAnimationFrame(renderLoop);
      renderer.render(scene, camera);
    }

    renderLoop();
  </script>
</body>
</html>
